<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">

    
      <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests; block-all-mixed-content; default-src 'self'; child-src 'self'; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net/; form-action 'self'; frame-src 'self'; img-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/ https://cdn.jsdelivr.net/; script-src 'self' 'unsafe-inline' https://www.google-analytics.com https://cdn.jsdelivr.net/; prefetch-src 'self'; connect-src 'self' https://www.google-analytics.com;">

    

    <meta name="author" content="Adhy">
    <meta name="description" content="Disclaimer: This is just my note for a talk &ldquo;An Introduction to Container Hacking&rdquo; by Rory McCune (Aqua Security)
Containers Containerisation is the process of packaging an application and the necessary resources (such as libraries and packages) required into one package.
The motivation behind containers is due to the myriad dependencies found in modern applications. These dependencies can:
be difficult to install create difficulty for devs to diagnose and replicate faults conflict with each other (e.">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Containers"/>
<meta name="twitter:description" content="Disclaimer: This is just my note for a talk &ldquo;An Introduction to Container Hacking&rdquo; by Rory McCune (Aqua Security)
Containers Containerisation is the process of packaging an application and the necessary resources (such as libraries and packages) required into one package.
The motivation behind containers is due to the myriad dependencies found in modern applications. These dependencies can:
be difficult to install create difficulty for devs to diagnose and replicate faults conflict with each other (e."/>

    <meta property="og:title" content="Containers" />
<meta property="og:description" content="Disclaimer: This is just my note for a talk &ldquo;An Introduction to Container Hacking&rdquo; by Rory McCune (Aqua Security)
Containers Containerisation is the process of packaging an application and the necessary resources (such as libraries and packages) required into one package.
The motivation behind containers is due to the myriad dependencies found in modern applications. These dependencies can:
be difficult to install create difficulty for devs to diagnose and replicate faults conflict with each other (e." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.adhysetiawan.com/posts/containers/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-09T14:22:26+08:00" />
<meta property="article:modified_time" content="2022-12-09T14:22:26+08:00" />


    <title>
  Containers · Adhy Setiawan
</title>

    
      <link rel="canonical" href="http://www.adhysetiawan.com/posts/containers/">
    

    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css" integrity="sha256-2f3b/&#43;byfmmYXcX&#43;BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.002ee2378e14c7a68f1f0a53d9694ed252090987c4e768023fac694a4fc5f793.css" integrity="sha256-AC7iN44Ux6aPHwpT2WlO0lIJCYfE52gCP6xpSk/F95M=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    <meta name="generator" content="Hugo 0.108.0">
  </head>

  
  
    
  
  <body class="preload-transitions colorscheme-auto">
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      Adhy Setiawan
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">Writeups</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://www.adhysetiawan.com/posts/containers/">
              Containers
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2022-12-09T14:22:26&#43;08:00">
                December 9, 2022
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              4-minute read
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/writeup/">writeup</a>
    </span></div>

        </div>
      </header>

      <div>
        
        <p>Disclaimer: This is just my note for a talk <a href="https://www.youtube.com/watch?v=udT99u-rTOQ">&ldquo;An Introduction to Container Hacking&rdquo;</a> by Rory McCune (Aqua Security)</p>
<h1 id="containers">
  Containers
  <a class="heading-link" href="#containers">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h1>
<p>Containerisation is the process of packaging an application and the necessary resources (such as libraries and packages) required into one package.</p>
<p>The motivation behind containers is due to the myriad dependencies found in modern applications. These dependencies can:</p>
<ul>
<li>be difficult to install</li>
<li>create difficulty for devs to diagnose and replicate faults</li>
<li>conflict with each other (e.g. multiple versions of python)</li>
</ul>
<p>Containerisation platforms make use of the <code>namespace</code> feature of the kernel, which is a feature used so that processes can access resources of the operating system without being able to interact with other processes.</p>
<p>Every process running on Linux will be assigned with two things: <code>namespace</code> and <code>PID</code>. Processes can only “see” other processes that are in the same namespace.</p>
<p>History of containers</p>
<ul>
<li>1979 - chroot system call</li>
<li>2000 - FreeBSD Jails</li>
<li>2001 - Linux Vserver</li>
<li>2004 - Solaris Zones</li>
<li>2008 - LXC</li>
<li>2013 - Docker</li>
</ul>
<p>Docker make use of existing Linux facilities to isolate each process from the underlying host and from each other.</p>
<ul>
<li>Process</li>
<li>Namespaces
<ul>
<li>mount namespace: the process can only see certain directories</li>
<li>network namespace: the process can only see certain network adapters</li>
</ul>
</li>
<li>Capabilities: break down root rights
<ul>
<li>In the old days: you are either root (all access), or not root (limited access)</li>
<li>allow a little bit of what root has without giving everything</li>
<li>In container context: we give every containers some capabilities</li>
</ul>
</li>
<li>cgroups: restrict how much resources a process can use
<ul>
<li>by default, docker does not set the cgroup</li>
<li>standard fork bomb will use all the process handles on the machine and DOS the machine</li>
</ul>
</li>
<li>AppArmor/SEinux: mandatory access control system
<ul>
<li>restrict what a process can do</li>
</ul>
</li>
<li>Seccomp: block individual linux kernel syscalls
<ul>
<li>docker blocks a set of “dangerous” linux kernel syscalls by default</li>
<li>kubernetes does not implement this by default</li>
</ul>
</li>
</ul>
<p><strong>Containers</strong> are just normal <strong>processes</strong></p>
<p>Demo:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ps aux | grep -i nginx
</span></span><span style="display:flex;"><span>** no result **
</span></span><span style="display:flex;"><span><span style="font-style:italic"># run a new docker container, with name &#39;nameserver&#39; with &#39;nginx&#39; image</span>
</span></span><span style="display:flex;"><span>docker run -d --name webserver nginx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># from the perspective of docker, we can see that docker has an instance of nginx</span>
</span></span><span style="display:flex;"><span>docker ps
</span></span><span style="display:flex;"><span>CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS    PORTS    NAMES
</span></span><span style="display:flex;"><span>XXXXxxxxxxxx    nginx    xxxxxxx    xxxxxxx    Up        80/tcp   webserver  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># from the host&#39;s perspective, we can see bunch of nginx processes</span>
</span></span><span style="display:flex;"><span>ps aux | grep -i nginx
</span></span><span style="display:flex;"><span>root     ROOT_PID ROOT_PID ... nginx: master process nginx -g daemon off;
</span></span><span style="display:flex;"><span>systemd+ PID      PID      ... nginx: worker process
</span></span><span style="display:flex;"><span>systemd+ PID      PID      ... nginx: worker process
</span></span><span style="display:flex;"><span>systemd+ PID      PID      ... nginx: worker process
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># docker exec will execute an command inside the container</span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># execute touch; create a new file called &#39;my_new_file&#39; in the root of the container&#39;s file system</span>
</span></span><span style="display:flex;"><span>docker exec webserver touch /my_new_file
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># we can access this file by accessing the proc filesystem</span>
</span></span><span style="display:flex;"><span>sudo ls /proc/ROOT_PID/root
</span></span><span style="display:flex;"><span>bin boot dev ... **my_new_file** ...
</span></span></code></pre></div><p><strong>A container image</strong> are just <strong>tarballs</strong> with <strong>json</strong> metadata</p>
<p>Demo:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="font-style:italic"># create a tarball out of the docker nginx image</span>
</span></span><span style="display:flex;"><span>docker save nginx:latest -o nginx-save.tar
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tar -xvf nginx-save.tar --one-top-level
</span></span><span style="display:flex;"><span>cd nginx-save
</span></span><span style="display:flex;"><span>ls
</span></span><span style="display:flex;"><span>&lt;sha256hash&gt; <span style="font-style:italic"># directories, one layer of dockerfile</span>
</span></span><span style="display:flex;"><span>&lt;sha256hash&gt; <span style="font-style:italic"># directories</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>&lt;sha256hash&gt;.json
</span></span><span style="display:flex;"><span>anifest.json
</span></span><span style="display:flex;"><span>repositories
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># using tree, we can see that each layer has another json file, an a layer.tar</span>
</span></span></code></pre></div><p>Instead of extracting each tarball which is time consuming, we can turn any running container into tarballs</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker export webesrver -o nginx-export.tar
</span></span><span style="display:flex;"><span>tar -xvf nginx-export.tar --one-top-level
</span></span><span style="display:flex;"><span>cd nginx-export.tar
</span></span><span style="display:flex;"><span>bin boot dev ... <span style="font-style:italic"># we can see the filesystem</span>
</span></span></code></pre></div><p><code>Docker Client</code> (command line program) talks to the <code>Docker Engine</code> through a linux socket file (which is a way of exposing a service locally without having to listen on the network) over HTTP REST API. <code>Docker Engine</code> talks to the <code>Docker Registry</code> (e.g. Docker Hub) to get the images. After getting the images, <code>Docker Engine</code> runs the processes (i.e. the <code>containers</code>).</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="font-style:italic"># get the docker socket and connect it to a temporary socket</span>
</span></span><span style="display:flex;"><span>sudo socat -v UNIX-LISTEN:/tmp/tempdock.sock,fork UNIX-CONNECT:/var/run/docker.sock
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># tell docker to connect to a different socket (our temporary socket)</span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># and then list the images</span>
</span></span><span style="display:flex;"><span>sudo docker -H unix:///tmp/tempdock.sock images
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># in our socat terminal, we can see the HTTP request sent by the Docker Engine</span>
</span></span></code></pre></div><p>“The most pointless Docker command ever”</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker run -ti --privileged --net=host --pid=host --ipc=host --volume /:/host busybox chroot /host
</span></span><span style="display:flex;"><span><span style="font-style:italic"># -ti                : give a terminal</span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># --privileged       : remove all security layers</span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># --net, --pid, --ipc: remove all the namespaces. Don&#39;t give the container a namespace resource, use HOST resource, etc.</span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># --volume           : mount the host&#39;s root file system inside the directory called /host</span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># busybox            : the name of the container</span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># chroot /host       : the command to be run by docker</span>
</span></span></code></pre></div>
      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    ©
    
    2022
     Adhy 
    ·
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

    </main>

    
      
      <script src="/js/coder.min.9cf2dbf9b6989ef8eae941ffb4231c26d1dc026bca38f1d19fdba50177d8a9ac.js" integrity="sha256-nPLb&#43;baYnvjq6UH/tCMcJtHcAmvKOPHRn9ulAXfYqaw="></script>
    

    

    

    

    

    

    

    

    
  </body>

</html>
